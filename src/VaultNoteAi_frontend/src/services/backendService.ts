import { Actor, HttpAgent, Identity } from '@dfinity/agent';
import { Principal } from '@dfinity/principal';
import { AuthClient } from '@dfinity/auth-client';

// Import the generated declarations (these will be available after dfx deploy)
// @ts-ignore - These will be generated by dfx
import { canisterId, createActor, VaultNoteAi_backend } from '../../../declarations/VaultNoteAi_backend';

export interface Note {
  id: string;
  title: string;
  content: string;
  encryptedContent: string;
  transcription?: string;
  summary?: string;
  tags: string[];
  createdAt: bigint;
  updatedAt: bigint;
  version: bigint;
  hash: string;
  owner: Principal;
}

export interface NoteInput {
  title: string;
  content: string;
  encryptedContent: string;
  transcription?: string;
  summary?: string;
  tags: string[];
  hash: string;
}

export type BackendError = 
  | { NotFound: null }
  | { Unauthorized: null }
  | { InvalidInput: null };

export type Result<T, E> = { ok: T } | { err: E };

class BackendService {
  private actor: any = null;
  private agent: HttpAgent | null = null;
  private currentIdentity: Identity | null = null;

  constructor() {
    // Initialize with anonymous identity for unauthenticated calls
    this.initializeWithAnonymous();
  }

  private async initializeWithAnonymous() {
    try {
      // Create agent for anonymous calls
      this.agent = new HttpAgent({
        host: import.meta.env.VITE_DFX_NETWORK === 'ic' 
          ? 'https://ic0.app' 
          : 'http://localhost:4943'
      });

      // Fetch root key for local development
      if (import.meta.env.VITE_DFX_NETWORK !== 'ic') {
        await this.agent.fetchRootKey();
      }

      // Create actor with anonymous identity
      this.actor = createActor(canisterId, {
        agent: this.agent,
      });
    } catch (error) {
      console.error('Failed to initialize backend service:', error);
    }
  }

  async initializeWithIdentity(identity: Identity) {
    try {
      // Store the identity
      this.currentIdentity = identity;

      // Create authenticated agent
      this.agent = new HttpAgent({
        identity,
        host: import.meta.env.VITE_DFX_NETWORK === 'ic' 
          ? 'https://ic0.app' 
          : 'http://localhost:4943'
      });

      // Fetch root key for local development
      if (import.meta.env.VITE_DFX_NETWORK !== 'ic') {
        await this.agent.fetchRootKey();
      }

      // Create authenticated actor
      this.actor = createActor(canisterId, {
        agent: this.agent,
      });

      console.log('üîó Backend service successfully initialized with authenticated identity');
      console.log('üåê Using host:', import.meta.env.VITE_DFX_NETWORK === 'ic' ? 'https://ic0.app' : 'http://localhost:4943');
    } catch (error) {
      console.error('Failed to initialize authenticated backend service:', error);
      throw error;
    }
  }

  async createNote(noteInput: NoteInput): Promise<Result<Note, BackendError>> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.createNote(noteInput);
      return result;
    } catch (error) {
      console.error('Error creating note:', error);
      throw error;
    }
  }

  async updateNote(noteId: string, noteInput: NoteInput): Promise<Result<Note, BackendError>> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.updateNote(noteId, noteInput);
      return result;
    } catch (error) {
      console.error('Error updating note:', error);
      throw error;
    }
  }

  async deleteNote(noteId: string): Promise<Result<boolean, BackendError>> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.deleteNote(noteId);
      return result;
    } catch (error) {
      console.error('Error deleting note:', error);
      throw error;
    }
  }

  async getNote(noteId: string): Promise<Result<Note, BackendError>> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.getNote(noteId);
      return result;
    } catch (error) {
      console.error('Error getting note:', error);
      throw error;
    }
  }

  async getUserNotes(): Promise<Note[]> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.getUserNotes();
      return result;
    } catch (error) {
      console.error('Error getting user notes:', error);
      throw error;
    }
  }

  async getUserNoteCount(): Promise<bigint> {
    if (!this.actor) {
      throw new Error('Backend service not initialized');
    }

    try {
      const result = await this.actor.getUserNoteCount();
      return result;
    } catch (error) {
      console.error('Error getting user note count:', error);
      throw error;
    }
  }

  // Utility method to check if user is authenticated
  isAuthenticated(): boolean {
    return this.currentIdentity?.getPrincipal().isAnonymous() === false;
  }

  // Get current user's principal
  getCurrentPrincipal(): Principal | null {
    return this.currentIdentity?.getPrincipal() || null;
  }
}

// Create a singleton instance
export const backendService = new BackendService();

// Export the class for testing purposes
export { BackendService }; 